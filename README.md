# CS-499 CAPSTONE

### Self-Assessment
Throughout my Computer Science program at Southern New Hampshire University, I felt like I gained a swath of foundational knowledge. Everything from programming embedded controllers all the way to implementing machine learning concepts in the form of Deep Q-learning to create a maze solver. Specifically related to the artifacts in this GitHub page, I feel like I have showcased my desire to learn new technologies that challenge me, my problem-solving skills in tackling issues within a project timeline, my ability to collaborate and work within a team, and lastly the topics of DS&A, SWE, and DBs discussed on this page.

My ability to push through the discomfort of not knowing a topic has been a strength of mine, best exemplified in the Android project. Before said project, I had for some time struggled with the intersection of UI/UX and functionality. This thought led me to understanding why there are separate roles of UI/UX designers and developers within teams; it requires different perspectives and sides of our brains to properly perform these tasks. This challenge forced me to integrate data analysis, algorithms, and visualization all in one impactful feature. Pushing through the fear of not realizing an end design was a struggle, but I'm glad I pressed on as the end result reinforced my new understanding of simple, thoughtful design paired with useful insights. Further, reinforcing my desire to recognize the fear and discomfort and push to the other side to achieve new knowledge and understanding.

Although these projects aren't a collaboration with other members of a team, I feel like I treated myself like every member of a dev team. At times I was a UI/UX designer; other times I was a back-end developer working on integrating the database with APIs that power the application's functionality. The conversations I had with myself offered many perspectives outside of my own on how an application/system's design is good or bad from different team member perspectives. This allowed me to come to understand the higher level of collaborating on ideas for a project, ensuring each piece of the design coincides with each member's abilities and picture of the end product.

Lastly, through all of the documentation of the many projects in my program, my strengths of understanding use cases of clients' and stakeholders' desires of a system's design have grown significantly. Understanding the complexities of the required features and boiling them down to their simple functions and reiterating it back to the stakeholders is critical in creating a reciprocal relationship of understanding. The developer team and stakeholders think at different levels, so some translation is necessary, and through documentation of system designs and flowcharts this gap is bridged. With this, my strength of discussing design at the appropriate level has become an incredible tool, even becoming useful in discussing a machine learning project using Deep Q-learning to my sister. Her not being within the world of CS, I broke down how the neural network allows for more efficient computation of all of the possible choices of either exploration or exploitation of the Q-learning model, leading us to a common understanding that this method is used to prevent the model from settling on a decent yet suboptimal strategy and push to find the most optimal strategy.

In reference to the artifacts included below, they further explore the learnings that reinforced some of these new and old strengths of mine through the enhancements focusing on software design, data structures and algorithms, and databases. These artifacts showcase foundational skills formed within my Bachelor's program.

### <a href="https://github.com/ZacharyHancock/CS499/tree/main/SWE_Artifact"> Artifact 1: Software Design and Engineering </a>
This artifact originates from CS-405: Secure Coding course. The <a href="https://github.com/ZacharyHancock/CS499/tree/main/SWE_Artifact/Original"> original artifact </a> is coded in C++ originally, showcasing different methods of secure coding principles from buffer overflow protection to SQL injection protection. The inclusion of this code as Artifact 1 is justified by complying with the following course outcomes: outcome 3 by demonstrating algorithmic design through secure encryption, outcome 4 by converting to Python libraries to demonstrate broad techniques and skills, and outcome 5 by implementing encryption algorithms and handling user data responsibly, demonstrating the application of secure software engineering principles.

While enhancing this artifact, I learned some cross-domain knowledge by converting the code from C++ to Python, which made me learn how to implement the same functionality with a different set of libraries and a higher-level language. The main challenge during this process was ensuring the proper and same logic and functionality while coding in a different language. This was challenging, like translating from English to Spanish and vice versa; in turn, this became a great learning benefit because it made me understand the intricacies and similarities/differences between the two languages. I further enhanced the artifact by enhancing the logic alongside the original plan of converting to Python. 

### <a href="https://github.com/ZacharyHancock/CS499/tree/main/DS%26A_Artifact/main"> Artifact 2: Algorithmns and Data Structures </a>
This artifact originates from CS-360: Mobile Architecture and Programming course. The <a href="https://github.com/ZacharyHancock/CS499/tree/main/DS%26A_Artifact/main/Original"> original artifact </a> is an Android app called WeightWare that has simple features including weight entry, a weight entries table, the ability to add/delete weights, and the ability to enable/disable SMS reminders to input weight entries. I included this artifact in the capstone because I remember not being fully comfortable with the union of UI/UX design and functionality while designing and programming the Android app. This made me want to dive back into it and get into some more uncomfortable territory by implementing more complicated features that would create a more intuitive and impactful end-user experience.

I accomplished the enhancement of this artifact by including new features like a line graph to visualize the trend of the user's weight inputs, a weight goal entry for inputting a goal weight, and lastly using slope-intercept form to predict what date the goal weight will be reached. In these enhanced features, I demonstrated skills in algorithms through the use of slope-intercept form to predict a date and enhanced UI/UX design principles by implementing the line graph to visualize trend analysis. Ultimately, these features created a more impactful end-user experience.

The outcomes that I set out to achieve, and accomplished, in this artifact enhancement are the following: outcome 3 by analyzing user data and generating meaningful predictions and trend analysis, and outcome 4 by integrating analytical and predictive methods showing the ability to use modern tools and technologies to deliver a meaningful feature that users value. The main challenge I faced was implementing the line graph; the struggle came from integrating it with the original source code. At some points, the graph would not update after a weight entry, as well as the line graph being populated in the wrong order, with dates reversed. To fix these, I had to update the listener for weight updates to include a refresh of the chart, as well as reversing the order of the graph to ensure a proper line graph with current real-time information. In conclusion, I feel like I met all the goals for this artifact enhancement, strengthening my confidence in integrating algorithms with UI/UX.

### <a href="https://github.com/ZacharyHancock/CS499/tree/main/DS%26A_Artifact/main"> Artifact 3: Databases </a>
This artifact originates from CS-340: Advanced Programming Concepts course. The <a href="https://github.com/ZacharyHancock/CS499/tree/main/Database_Artifact/Original"> original artifact </a> is a web dashboard using Dash that allows the user to navigate a database of animal shelters that holds different breeds of cats and dogs, including geographical location to allow the user to easily find the animal they are looking for, as well as filtering breed choices based on activities like water rescue, mountain/wilderness rescue, and disaster/individual tracking.

I included this artifact in the capstone because it showcases the integration of database analysis, Dash app development that demonstrates building an app that's scalable, and lastly my enhancement with the inclusion of a RESTful API that further builds on scalability and maintainability. The specific skills that I demonstrated in the enhancement were the use of different technologies and APIs to create a cohesive end product, from creating a MongoDB container in Docker for an isolated development and testing environment, MongoDB itself by initializing the data collection to hold the entries, Postman to test said RESTful API, Dash development to create an intuitive, user-friendly web experience, and lastly the development of the RESTful API that showcases my ability to create a standardized and scalable way for the system to communicate in the modern environment.

The process of enhancing this artifact sought out, and accomplished, the following course outcomes: outcome 1 by designing and implementing a database-backed application, and outcome 2 by using modern frameworks, like RESTful APIs, to integrate the front and backend. What I learned while creating this API was firstly that using Docker was a more seamless experience than I thought it would be, becoming a useful tool for future testing and deployments of apps. Secondly, utilizing Postman to test RESTful APIs has been and still remains an important tool in my belt. Lastly, creating RESTful APIs is an incredibly intuitive and powerful way to make a web-connected app more scalable and flexible.

The main challenge I faced in this development was updating some outdated libraries in my source code. Originally, on startup, I had issues initializing the Dash app under JupyterDash, and after some research, I came to find out that it had been deprecated and merged all into Dash within the dash module. A simple fix, but unforeseen in the beginning. After that slight hiccup, everything else was smooth sailing. In conclusion, the goal to implement more scalability through the use of a RESTful API was achieved.

### Code Review
<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/pI5dkcrz3kU"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>


